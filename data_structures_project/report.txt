The data structure I used was a hash table.
However, this hash table is a variant upon the std::unordered_map as it utilizes the follow techniques:
  1) Open addressing
    -All inserted key/value pairs are confined within a range a 64
    -If desired index is taken in the underlying array, the first aviable index within the 64 range is taken.
    -The table increases in size when a 64 range is filled or when the table is capped out
  2) Faster hashing
    -To get the desired index within the underlying array, a simple logical "AND" operation is taken of the capacity (which is a power of two) minus one, and the 64bit hash. This produces a result between 0 and the capacity.
  3) Data Locality
    -The entire hash table is kept in a sigle contigious array 
  4) Meatdata
    -Inspired by google's flash_hash_map, Each key/value pair is associated with an 8 bit piece of metadata. The First bit indicates weather the position is full/empty and the last 7 bits are the 7 least significant bits of the 64 bit hash.
      - https://github.com/abseil/abseil-cpp/container
  5) Intel's SSE and AVX SIMD instructions.
    -To utilize intel x86 architecture, the hash table is arranged in the follow way.
      -64 8bit metadata entries followed by 64 corresponding key/value entires
      -these are called "bucket_groups"
      -Inspiration for condension into metadata/k/v groups
        - https://github.com/skarupke/flat_hash_map/bytell_hash.map.hpp
    -The 64 8bit metadata entires are fed into Intel's SIMD functions and vectors.
      -SSE2/3 -> 4 128bit registers
      -AVX2 ->   2 256bit registers
      -AVX512 -> 1 512 bit register
    -To find a key/value pair, the 7 least significant bits of the key's hash are compared against each of the 64 metadata entries via a logical AND operation. If any of the metadata entries match the 7bit partial hash, only those key's are compared with the input key.
    -Using SIMD, the logical AND operation and condensing of the result into 64 bits is done in 4/2/1 instruction(s) vs the 64 instructions normally taken without SIMD.
    -For example, if a key's hash's 7 least significant bits = 0101101, this is logical AND'd with each metadata entry (disregarding the first bit as it's used to indicate the presence of a key/value pair). The 512bit result is then compressed into 64 bits with a 1 indicating a match, and 0 indicating a miss. 
  -See the following link on the avaible for Intel's Intrinsic Instructions (the SSE/AVX instructions)
    - https://software.intel.com/sites/landingpage/IntrinsicsGuide/

Final Note:
There is still work to be done on this project concerning it's API.
My intention is to update it to be similar to std::unordered_map's API and optimize my use of move and reference semantincs. The provided implementation however is fully functional with some methods as seen in the README.  
